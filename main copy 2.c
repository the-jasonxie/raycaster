//
//  main.c
//  Raycaster
//
//  Created by Jason Xie on 1/22/24.
//
// IMPORTANT! There are instances where code using the Simple DirectMedia Layer (SDL) package were generated by a language model. Lines of these instances are indicated as such.

#include "raycaster.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>

int main(int argc, const char * argv[]) {
    SDL_Window* Window = SDL_CreateWindow("Raycaster", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, ScreenWidth, ScreenHeight, SDL_WINDOW_SHOWN); // Generated by language model
    SDL_Renderer* Renderer = SDL_CreateRenderer(Window, -1, SDL_RENDERER_ACCELERATED); // Generated by language model
    
    if (!Window || !Renderer)
    {
        printf("ERROR! Some error occured when attempting to open the window or renderer!\n");
        return 1;
    }
    
    SDL_Texture* SpriteTextures[SPRITE_IMAGES] = {NULL};
    
    for (int i = 0; i < SPRITE_IMAGES; i++)
    {
        for (int i = 0; i < NumberOfSprites; i++) {
            SpriteIDTable[i] = Sprites[i].ID;
        }
        SpriteIDIndex = SpriteIDTable[i];
        
        char filepath[100];
        sprintf(filepath, "/Users/jasonxie/Documents/Xcode Apps/Raycaster/Sprites/sprite_%d.png", i);
        
        SDL_Surface* SpriteSurface = IMG_Load(filepath);
        if (SpriteSurface == NULL) {
            printf("ERROR! Couldn't find sprite_%d.png\n", i);
            if (i == 0)
            {
                printf("\nYou may have prevented Xcode from accessing files...modify the code then revert it to reprompt the editor\n\n");
            }
            return 1;
        }
        
        SpriteTextures[SpriteIDIndex] = SDL_CreateTextureFromSurface(Renderer, SpriteSurface);
        SDL_FreeSurface(SpriteSurface);
        
        if (SpriteTextures[SpriteIDIndex] == NULL) {
            printf("ERROR! Some error occured when attempting to create a texture for a sprite!\n");
            return 1;
        }
    }
    
    SDL_Event *event = malloc(sizeof(SDL_Event)); // Generated by language model
        
    bool ProgramRunning = true;
    // int debug = 0;
    while (ProgramRunning)
    {
        // While SDL remains open
        while (SDL_PollEvent(event) != 0) // Generated by language model
        {
            // Handle quit event
            if (event->type == SDL_QUIT) // Generated by language model
            {
                ProgramRunning = false;
            }
            // Generated by language model; if a key is being pressed
            else if (event->type == SDL_KEYDOWN) 
            {
                keyState[event->key.keysym.scancode] = true;
            }
            // Generated by language model; if a key is released
            else if (event->type == SDL_KEYUP) 
            {
                keyState[event->key.keysym.scancode] = false;
            }
                
        }

        // Fills renderer with ceiling + floor
        SDL_SetRenderDrawColor(Renderer, 50, 50, 50, 255);
        SDL_RenderFillRect(Renderer, &(SDL_Rect){0, 0, ScreenWidth, ScreenHeight / 2}); // Generated by language model
        SDL_SetRenderDrawColor(Renderer, 20, 20, 20, 255);
        SDL_RenderFillRect(Renderer, &(SDL_Rect){0, ScreenHeight / 2, ScreenWidth, ScreenHeight / 2}); // Generated by language model

        // Checks for player movement
        PlayerMovement();
        
        // DEPRECATED
        SDL_GetMouseState(&CursorX, &CursorY); // Generated by language model
        
        // Variales to figure out how many rays to calculate
        int Pixel = ScreenWidth;
        float RayDegreeInterval = (float) FieldOfView / ScreenWidth; // Every how many degrees should a ray be cast
        
        
        
        
        
        
        
        
        
        
        for (double RayDegree = -(FieldOfView / 2); RayDegree <= (FieldOfView / 2); RayDegree += RayDegreeInterval) // If FOV = 60 degrees, iterates from -30 to 30 degrees. NOT absolute angles!
        {
            double RayRadian = RayDegree * M_PI / 180;
            DirectionAbsoluteRadian = atan2(DirectionY, DirectionX);
            
            for (int ObjectIdentifying = 0; ObjectIdentifying < 1; ObjectIdentifying++)
            {
                ;
            }
            float Value = CalculateRay(1, RayRadian, PlayerX, PlayerY, DirectionX, DirectionY);
            
            
             // FIX AND MKAE RAYCASTING!
            if (Value < 0.000001) // Prevents dividing by zero
            {
                Value = 0.000001;
            }
            
            double Calculator = DirectionAbsoluteRadian + RayRadian;
            if (Calculator > M_PI)
            {
                Calculator -= 2 * M_PI;
            }
            else if (Calculator < -1 * M_PI)
            {
                Calculator += 2 * M_PI;
            }
            
            float NotUsingThis = (pow(Value, 1.9) / 10); // Makes farther lines appear darker for depth perception. Exponentially!
            if (NotUsingThis < 1.5) // Prevents weird numbers after dividing by a small number.
            {
                NotUsingThis = 1.5;
            }
            if (fabs(Calculator + M_PI / 2) < 0.001) // DEPRECATED
            {
                SDL_SetRenderDrawColor(Renderer, (0), (255), (255), 255);
                SDL_RenderDrawLine(Renderer, Pixel, ((ScreenHeight / 2) - (ScreenHeight / 2) / Value), Pixel, ((ScreenHeight / 2) + (ScreenHeight / 2) / Value));
            }
            else
            {
                SDL_SetRenderDrawColor(Renderer, (255 / NotUsingThis), (255 / NotUsingThis), (255 / NotUsingThis), 255);
                SDL_RenderDrawLine(Renderer, Pixel, ((ScreenHeight / 2) - (ScreenHeight / 2) / Value), Pixel, ((ScreenHeight / 2) + (ScreenHeight / 2) / Value));
            }
            
            
            // NEW CODE!
            SortSprites();
            
            
            for (int i = 0; i < NumberOfSprites; i++)
            {
                for (int j = 0; j < NumberOfSprites; j++) {
                    SpriteIDTable[j] = Sprites[j].ID;
                }
                SpriteIDIndex = SpriteIDTable[i];
                
                Sprites[i].AngleToPlayer = atan2(Sprites[i].LocationY - PlayerY, Sprites[i].LocationX - PlayerX);
                
                if (fabs(Sprites[i].AngleToPlayer - Calculator) < 0.001) // Tolerance level.
                {
                    float test = DirectionAbsoluteRadian + RayRadian;
                    Sprites[i].Pixel = Pixel;
                    Sprites[i].PlayerToWallDistance = Value;
                    Calculator = Calculator * 180 / M_PI;
                   // printf("%f\n", Calculator);
                    
                    if (Sprites[i].DistanceToPlayer < Sprites[i].PlayerToWallDistance)
                    {
                        SDL_SetRenderDrawColor(Renderer, (255), (255), (255), 255);
                        SDL_RenderDrawLine(Renderer, Pixel, ((ScreenHeight / 2) - (ScreenHeight / 2) / Value), Pixel, ((ScreenHeight / 2) + (ScreenHeight / 2) / Value));
                        SDL_Rect SpriteRect = {Sprites[i].Pixel, ((ScreenHeight / 2) - (ScreenHeight / 2) / Sprites[i].DistanceToPlayer), 2 * ((ScreenHeight / 2) / Sprites[i].DistanceToPlayer), (2 * (ScreenHeight / 2) / Sprites[i].DistanceToPlayer)};
                        SDL_Texture* Texture = SpriteTextures[SpriteIDIndex];
                        SDL_RenderCopy(Renderer, Texture, NULL, &SpriteRect);
                    }
                }
            }
            
            if (Pixel < 0)
            {
                Pixel = ScreenWidth;
            }
            else
            {
                Pixel--;
            }
        }
        
        
        
        for (int i = 0; i < NumberOfSprites; i++)
        {
            ;
        }
        
        
        // Presents drawn renderer to screen
        SDL_RenderPresent(Renderer); // Generated by language model
    }
    
    SDL_DestroyWindow(Window); // Generated by language model
    SDL_Quit(); // Generated by language model
    free(event);
    return 0;

}

float CalculateRay(int ObjectIdentifying, float RayRadian, float PlayerX, float PlayerY, float DirectionX, float DirectionY)
{
    // Calculates the lowest distance between vertical and horizontal traversals
    float LowestDistance = 0;
    
    // Gets ray,and it's direction  in standard position
    DirectionAbsoluteRadian = atan2(DirectionY, DirectionX);
    float RayX = DirectionX + cosf(DirectionAbsoluteRadian + RayRadian);
    float RayY = DirectionY + sinf(DirectionAbsoluteRadian + RayRadian);
    
    // Temporary variables that check for iterates up and checks for ray collision with wall
    float xTraverse;
    float yTraverse;
    
    float DistToStart;
    float DistanceFromStart;
    int const MAXCHECK = 20;
    
    // Checks for horizontal intersection
    if (RayX > 0)
    {
        DistToStart = (1 - (PlayerX - (int) PlayerX));
        xTraverse = PlayerX + DistToStart;
        yTraverse = PlayerY + RayY * (DistToStart / RayX);
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) xTraverse][(int) yTraverse] == ObjectIdentifying)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                }
                break;
            }
            
            xTraverse += 1;
            yTraverse += (RayY / RayX);
        }
        
    }
    else if (RayX < 0)
    {
        DistToStart = PlayerX - (int) PlayerX;
        xTraverse = PlayerX - DistToStart;
        yTraverse = PlayerY - RayY * (DistToStart / RayX);
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) (xTraverse - 1)][(int) yTraverse] == ObjectIdentifying)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                }
                break;
            }
            
            xTraverse -= 1;
            yTraverse -= (RayY / RayX);
        }
    }
    
    // Checks for vertical intersection
    if (RayY > 0)
    {
        DistToStart = (1 - (PlayerY - (int) PlayerY));
        yTraverse = PlayerY + DistToStart;
        xTraverse = PlayerX + RayX * (DistToStart / RayY);
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) xTraverse][(int) yTraverse] == ObjectIdentifying)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                }
                break;
            }
            
            yTraverse += 1;
            xTraverse += (RayX / RayY);
        }
    }
    else if (RayY < 0)
    {
        DistToStart = PlayerY - (int) PlayerY;
        yTraverse = PlayerY - DistToStart;
        xTraverse = PlayerX - (RayX * (DistToStart / RayY));
        
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) xTraverse][(int) (yTraverse - 1)] == ObjectIdentifying)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                }
                break;
            }
            
            yTraverse -= 1;
            xTraverse -= (RayX / RayY);
        }
    }
    
    if (LowestDistance < 0.000001)
    {
        return 9999999; // debugging
    }
    else
    {
        return LowestDistance;
    }
}
 
bool PlayerCollision(float coordinateX, float coordinateY)
{
    if (Map[(int) coordinateX][(int) coordinateY] != 0)
    {
        return true;
    }
    else
    {
        return false;
    }
}
 
void PlayerMovement(void)
{
    // Tests for collision
    float NewX;
    float NewY;
    float RotateRadian;
    
    // Variable
    float MovementSpeed = 0.01;
    float const RotateSpeed = 0.5;
    
    if (keyState[SDL_SCANCODE_W])
    {
        // Checks for "running"
        if (keyState[SDL_SCANCODE_LSHIFT])
        {
            MovementSpeed *= 2.2;
        }
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        MovementSpeed = 0.002;
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_A]) 
    {
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian + M_PI / 2));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian + M_PI / 2));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_S]) 
    {
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian + M_PI));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian + M_PI));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_D]) 
    {
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian + 3 * M_PI / 2));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian + 3 * M_PI / 2));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_LEFT]) 
    {
        RotateRadian = RotateSpeed * M_PI / 180;
        DirectionX = DirectionX * cosf(RotateRadian) - DirectionY * sinf(RotateRadian);
        DirectionY = DirectionX * sinf(RotateRadian) + DirectionY * cosf(RotateRadian);
    }
    if (keyState[SDL_SCANCODE_RIGHT]) 
    {
        RotateRadian = RotateSpeed * M_PI / 180;
        DirectionX = DirectionX * cosf(RotateRadian) + DirectionY * sinf(RotateRadian);
        DirectionY = -DirectionX * sinf(RotateRadian) + DirectionY * cosf(RotateRadian);
    }
}

void SortSprites(void)
{
    for (int i = 0; i < NumberOfSprites; i++)
    {
        for (int i = 0; i < NumberOfSprites; i++) {
            SpriteIDTable[Sprites[i].ID] = i;
        }
        SpriteIDIndex = SpriteIDTable[i];
        
        Sprites[SpriteIDIndex].DistanceToPlayer = sqrtf((Sprites[SpriteIDIndex].LocationX - PlayerX) * (Sprites[SpriteIDIndex].LocationX - PlayerX) + (Sprites[SpriteIDIndex].LocationY - PlayerY) * (Sprites[SpriteIDIndex].LocationY - PlayerY));
    }
    
    qsort(Sprites, NumberOfSprites, sizeof(Sprite), Comparator);
}

int Comparator(const void *a, const void *b)
{
    Sprite *SpriteA = (Sprite *)a;
    Sprite *SpriteB = (Sprite *)b;
    if (SpriteA->DistanceToPlayer > SpriteB->DistanceToPlayer)
    {
        return 1;
    } 
    else if (SpriteA->DistanceToPlayer < SpriteB->DistanceToPlayer)
    {
        return -1;
    }
    else
    {
        return 0;
    }
}


/*
 1. For each pixel, record down the distance to a wall (or object) or sprite if applicable.
    Example: 1: wall 5, sprite 3; 2: wall 4, 3: wall 6
 2. Start to render each thing on screen from farthest to clsest.
    Example. First render 3: wall 6, 1: wall 5, 2: wall 4, then 1: sprite 3.
 
 3.
 
 struct ObjectOrWall {
    Pixel // multiple of these
    Distance // one of this
 }
 
 
 
 // Create one of the above every time you check if a precision sprite
 // Sort
 
 
 int compareMyStructs(const void *a, const void *b) {
     // Cast the arguments to pointers to MyStruct
     const MyStruct *structA = (const MyStruct *)a;
     const MyStruct *structB = (const MyStruct *)b;

     // Compare the sharedValue fields of the structs
     if (structA->sharedValue < structB->sharedValue) {
         return -1;
     } else if (structA->sharedValue > structB->sharedValue) {
         return 1;
     } else {
         return 0;
     }
 }z
 
 
 
 */


