//
//  main.c
//  Raycaster
//
//  Created by Jason Xie on 1/22/24.
//
// IMPORTANT! There are instances where code using the Simple DirectMedia Layer (SDL) package were generated by a language model. Lines of these instances are indicated as such.

#include "raycaster.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <SDL2/SDL.h>
#include <SDL2/SDL_image.h>

int main(int argc, const char * argv[]) {
    SDL_Window* Window = SDL_CreateWindow("Raycaster", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, ScreenWidth, ScreenHeight, SDL_WINDOW_SHOWN); // Generated by language model
    SDL_Renderer* Renderer = SDL_CreateRenderer(Window, -1, SDL_RENDERER_ACCELERATED); // Generated by language model
    
    if (!Window || !Renderer)
    {
        printf("ERROR! Some error occured when opening the window or renderer.\n");
        return 1;
    }
    
    bool ProgramRunning = true;
    SDL_Event *event = malloc(sizeof(SDL_Event)); // Generated by language model
    
    SDL_Surface *spriteSurface = IMG_Load("/Users/jasonxie/Documents/Xcode Apps/Raycaster/Sprites/joe_biden_cc.png");
    if (spriteSurface == NULL) {
        printf("ERROR! Image not found! %s\n", IMG_GetError());
        return 1;
    }
    
    SDL_Texture *spriteTexture = SDL_CreateTextureFromSurface(Renderer, spriteSurface);
    SDL_FreeSurface(spriteSurface);
    if (spriteTexture == NULL) {
        SDL_Log("Unable to create texture: %s", SDL_GetError());
        return 1;
    }
    
    
    
    
    
    
    while (ProgramRunning)
    {
        // While SDL remains open
        while (SDL_PollEvent(event) != 0) // Generated by language model
        {
            // Handle quit event
            if (event->type == SDL_QUIT) // Generated by language model
            {
                ProgramRunning = false;
            }
            // Generated by language model; if a key is being pressed
            else if (event->type == SDL_KEYDOWN) 
            {
                keyState[event->key.keysym.scancode] = true;
            }
            // Generated by language model; if a key is released
            else if (event->type == SDL_KEYUP) 
            {
                keyState[event->key.keysym.scancode] = false;
            }
                
        }

        // Fills renderer with empty canvas
        SDL_SetRenderDrawColor(Renderer, 0, 0, 0, 255);
        SDL_RenderClear(Renderer);

        // Checks for player movement
        PlayerMovement();
        
        // DEPRECATED
        SDL_GetMouseState(&CursorX, &CursorY); // Generated by language model
        
        // Variales to figure out how many rays to calculate
        int Pixel = ScreenWidth;
        float RayDegreeInterval = (float) FieldOfView / ScreenWidth; // Every how many degrees should a ray be cast
        
        //
        for (float RayDegree = -(FieldOfView / 2); RayDegree <= (FieldOfView / 2); RayDegree += RayDegreeInterval) // If FOV = 60 degrees, iterates from -30 to 30 degrees
        {
            // 
            float Value = CalculateRay(RayDegree, PlayerX, PlayerY, DirectionX, DirectionY); // Calculates the distance
            if (Value < 0.000001) // Prevents dividing by zero
            {
                Value = 0.000001;
            }
            float DrawDistance = (pow(Value, 1.9) / 10); // Makes farther lines appear darker for depth perception. Exponentially!
            if (DrawDistance < 1.5) // Prevents weird numbers after dividing by a small number.
            {
                DrawDistance = 1.5;
            }
            if (isHorizontal)
            {
                SDL_SetRenderDrawColor(Renderer, (255 / DrawDistance), (255 / DrawDistance), (255 / DrawDistance), 255);
                SDL_RenderDrawLine(Renderer, Pixel, ((ScreenHeight / 2) - (ScreenHeight / 2) / Value), Pixel, ((ScreenHeight / 2) + (ScreenHeight / 2) / Value));
            }
            else
            {
                SDL_SetRenderDrawColor(Renderer, (210 / DrawDistance), (210 / DrawDistance), (210 / DrawDistance), 255);
                SDL_RenderDrawLine(Renderer, Pixel, ((ScreenHeight / 2) - (ScreenHeight / 2) / Value), Pixel, ((ScreenHeight / 2) + (ScreenHeight / 2) / Value));
            }
            
            // Store for each pixel a list of distances and render each in an order based on the value of each. Genius!
            
            if (Pixel < 0)
            {
                Pixel = ScreenWidth;
            }
            else
            {
                Pixel--;
            }
        }
        
        
        
        SDL_Rect spriteRect = {0, 0, 400, 400}; // Example position and size
        SDL_RenderCopy(Renderer, spriteTexture, NULL, &spriteRect);
        
        // Presents drawn renderer to screen
        SDL_RenderPresent(Renderer); // Generated by language model
    }
    
    SDL_DestroyWindow(Window); // Generated by language model
    SDL_Quit(); // Generated by language model
    free(event);
    return 0;

}

float CalculateRay(float RayDegree, float PlayerX, float PlayerY, float DirectionX, float DirectionY)
{
    // Calculates the lowest distance between vertical and horizontal traversals
    float LowestDistance = 0;
    
    // Gets ray, and it's direction  in standard position
    float RayRadian = RayDegree * M_PI / 180;
    DirectionAbsoluteRadian = atan2(DirectionY, DirectionX);
    float RayX = DirectionX + cosf(DirectionAbsoluteRadian + RayRadian);
    float RayY = DirectionY + sinf(DirectionAbsoluteRadian + RayRadian);
    
    // Temporary variables that check for iterates up and checks for ray collision with wall
    float xTraverse;
    float yTraverse;
    
    float DistToStart;
    float DistanceFromStart;
    int const MAXCHECK = 10;
    
    // Checks for horizontal intersection
    if (RayX > 0)
    {
        DistToStart = (1 - (PlayerX - (int) PlayerX));
        xTraverse = PlayerX + DistToStart;
        yTraverse = PlayerY + RayY * (DistToStart / RayX);
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) xTraverse][(int) yTraverse] != 0)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                    isHorizontal = true;
                }
                break;
            }
            
            xTraverse += 1;
            yTraverse += (RayY / RayX);
        }
        
    }
    else if (RayX < 0)
    {
        DistToStart = PlayerX - (int) PlayerX;
        xTraverse = PlayerX - DistToStart;
        yTraverse = PlayerY - RayY * (DistToStart / RayX);
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) (xTraverse - 1)][(int) yTraverse] != 0)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                    isHorizontal = true;
                }
                break;
            }
            
            xTraverse -= 1;
            yTraverse -= (RayY / RayX);
        }
    }
    
    // Checks for vertical intersection
    if (RayY > 0)
    {
        DistToStart = (1 - (PlayerY - (int) PlayerY));
        yTraverse = PlayerY + DistToStart;
        xTraverse = PlayerX + RayX * (DistToStart / RayY);
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) xTraverse][(int) yTraverse] != 0)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                    isHorizontal = false;
                }
                break;
            }
            
            yTraverse += 1;
            xTraverse += (RayX / RayY);
        }
    }
    else if (RayY < 0)
    {
        DistToStart = PlayerY - (int) PlayerY;
        yTraverse = PlayerY - DistToStart;
        xTraverse = PlayerX - (RayX * (DistToStart / RayY));
        
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break;
            }
            if (Map[(int) xTraverse][(int) (yTraverse - 1)] != 0)
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001)
                {
                    LowestDistance = DistanceFromStart;
                    isHorizontal = false;
                }
                break;
            }
            
            yTraverse -= 1;
            xTraverse -= (RayX / RayY);
        }
    }
    
    if (LowestDistance < 0.000001)
    {
        return 9999999;
    }
    else
    {
        return LowestDistance;
    }
}
 
bool PlayerCollision(float coordinateX, float coordinateY)
{
    if (Map[(int) coordinateX][(int) coordinateY] != 0)
    {
        return true;
    }
    else
    {
        return false;
    }
}
 
void PlayerMovement(void)
{
    // Tests for collision
    float NewX;
    float NewY;
    float RotateRadian;
    
    // Variable
    float MovementSpeed = 0.01;
    float const RotateSpeed = 0.5;
    
    if (keyState[SDL_SCANCODE_W])
    {
        // Checks for "running"
        if (keyState[SDL_SCANCODE_LSHIFT])
        {
            MovementSpeed *= 2.2;
        }
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        MovementSpeed = 0.002;
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_A]) 
    {
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian + M_PI / 2));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian + M_PI / 2));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_S]) 
    {
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian + M_PI));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian + M_PI));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_D]) 
    {
        NewX = (PlayerX + MovementSpeed * cosf(DirectionAbsoluteRadian + 3 * M_PI / 2));
        NewY = (PlayerY + MovementSpeed * sinf(DirectionAbsoluteRadian + 3 * M_PI / 2));
        if (!PlayerCollision(NewX, NewY))
        {
            PlayerX = NewX;
            PlayerY = NewY;
        }
        printf("%f, %f\n", PlayerX, PlayerY);
    }
    if (keyState[SDL_SCANCODE_LEFT]) 
    {
        RotateRadian = RotateSpeed * M_PI / 180;
        DirectionX = DirectionX * cosf(RotateRadian) - DirectionY * sinf(RotateRadian);
        DirectionY = DirectionX * sinf(RotateRadian) + DirectionY * cosf(RotateRadian);
    }
    if (keyState[SDL_SCANCODE_RIGHT]) 
    {
        RotateRadian = RotateSpeed * M_PI / 180;
        DirectionX = DirectionX * cosf(RotateRadian) + DirectionY * sinf(RotateRadian);
        DirectionY = -DirectionX * sinf(RotateRadian) + DirectionY * cosf(RotateRadian);
    }
}
