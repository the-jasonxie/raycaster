//
//  main.c
//  Raycaster
//
//  Created by Jason Xie on 1/22/24.
//
// IMPORTANT! There are instances where code using the Simple DirectMedia Layer (SDL) package were generated by a language model. Lines of these instances are indicated as such.

#include "raycaster.h"
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <math.h>
#include <SDL2/SDL.h>

int main(int argc, const char * argv[]) {
    

    int const ScreenWidth = 1280;
    int const ScreenHeight = 800;
    int const FieldOfView = 60; // Field of view in degrees
    
    
    struct Ray
    {
        float Interval; // What interval of degree it's in
        float VectorX;
        float VectorY;
    };
    
    
    float RayDegreeInterval = (float) FieldOfView / ScreenWidth; // Every how many degrees should a ray be cast

    
    SDL_Window* Window = SDL_CreateWindow("Raycaster", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, ScreenWidth, ScreenHeight, SDL_WINDOW_SHOWN); // Generated by language model
    SDL_Renderer* Renderer = SDL_CreateRenderer(Window, -1, SDL_RENDERER_ACCELERATED); // Generated by language model

    if (!Window || !Renderer)
    {
        printf("Some error occured when opening the window or renderer.");
        return 1;
    }
    
    
    bool ProgramRunning = true;
    SDL_Event *event = malloc(sizeof(SDL_Event)); // Generated by language model
    while (ProgramRunning)
    {
        SDL_SetRenderDrawColor(Renderer, 0, 0, 0, 255);
        SDL_RenderClear(Renderer);
        
        int Pixel = ScreenWidth;
        for (float RayDegree = -30; RayDegree <= 30; RayDegree += RayDegreeInterval)
        {
            float Value = CalculateRay(RayDegree, PlayerX, PlayerY, DirectionX, DirectionY);
            if (isHorizontal)
            {
                SDL_SetRenderDrawColor(Renderer, 255, 255, 255, 255);
                if (Value > 0.00001)
                {
                    SDL_RenderDrawLine(Renderer, Pixel, ((ScreenHeight / 2) - (ScreenHeight / 3) / Value), Pixel, ((ScreenHeight / 2) + (ScreenHeight / 3) / Value));
                }
                else
                {
                    SDL_RenderDrawLine(Renderer, Pixel, (Pixel - Pixel), Pixel, ScreenWidth);
                }
            }
            else
            {
                SDL_SetRenderDrawColor(Renderer, 255, 0, 255, 255);
                if (Value > 0.00001)
                {
                    SDL_RenderDrawLine(Renderer, Pixel, ((ScreenHeight / 2) - (ScreenHeight / 3) / Value), Pixel, ((ScreenHeight / 2) + (ScreenHeight / 3) / Value));
                }
                else
                {
                    SDL_RenderDrawLine(Renderer, Pixel, (Pixel - Pixel), Pixel, ScreenWidth);
                }
            }

           //  printf("Pixel, %i, Degree: %f, Value: %f\n", Pixel, RayDegree, Value);

            
            // printf("Pixel: %i,  Value: %f\n", Pixel, Value);
            if (Pixel < 0)
            {
                Pixel = 800;
            }
            else
            {
                Pixel--;
            }
        }
    
        
        SDL_RenderPresent(Renderer);
        
        while (SDL_PollEvent(event) != 0) // Generated by language model
        {
            if (event->type == SDL_QUIT)
            {
                // Handle quit event
                ProgramRunning = false;
            }
            else if (event->type == SDL_KEYDOWN)
            {
                HandleMovement(event);
            }
                
        }
    }
    
    SDL_DestroyWindow(Window); // Generated by language model
    SDL_Quit(); // Generated by language model
    free(event);
    return 0;

}

float CalculateRay(float RayDegree, float PlayerX, float PlayerY, float DirectionX, float DirectionY)
{
    // printf("\n\n");
    // printf("PlayerX: %f, PlayerY: %f\n", PlayerX, PlayerY);
    // printf("DirectionX: %f, DirectionY: %f\n", DirectionX, DirectionY);
    float RayRadian = RayDegree * M_PI / 180;
    

    
    // double DirectionAbsolute = ((RelativeRayX * RelativeRayY + DirectionX * DirectionY) / (sqrtf(RelativeRayX * RelativeRayX + RelativeRayY * RelativeRayY) * (sqrtf(DirectionX * DirectionX + DirectionY * DirectionY))));

    DirectionAbsoluteRadian = atan2(DirectionY, DirectionX);
        
    // printf("%f\n", RayDegree);
    // printf("%f\n", test);
    
    float RayX = DirectionX + cosf(DirectionAbsoluteRadian + RayRadian); // We're going to  use these values to check what direction RayX and RayY are facing
    // printf("RayX: %f\n", RayX);
    float RayY = DirectionY + sinf(DirectionAbsoluteRadian + RayRadian);
    // printf("RayY: %f\n", RayY);
    // printf("Radian: %f, RayX: %f, RayY: %f\n", RayRadian, RayX, RayY);
    float LowestDistance = 0;
    
    float xTraverse; // We're going to use these value and increment them across grids to check for fill
    float yTraverse;
    float DistToStart;
    float ConfiguredDistance;
    float DistanceFromStart;
    
    

    
    // 1 + 30 degrees -> 1.5, 0.866
    
    // printf("RayX: %f, Global: %f, RayY: %f\n", RayX, RayRadian, RayY);

    // Horiz
    if (RayX > 0) // if the player is facing non-vert try to check for an intersection horizontally againsta  wall
    {
        DistToStart = (1 - (PlayerX - (int) PlayerX)); // Configure the distance to get to a horizontal grid line
        
        // printf("we're in Ray X > 0\n");
        xTraverse = PlayerX + DistToStart;
        yTraverse = PlayerY + RayY * (DistToStart / RayX);
        ConfiguredDistance = sqrtf((yTraverse - PlayerY) * (yTraverse - PlayerY) + (xTraverse - PlayerX) * (xTraverse - PlayerX)); // This probably (definintely) can be optimized)
        
        // printf("ConfiguredDistance: %f, xTraverse: %f, yTraverse: %f, DistToStart: %f\n", ConfiguredDistance, xTraverse, yTraverse, DistToStart);
        
        for (int i = 0; i < MAXCHECK; i++)
        {
            // printf("%i, %i\n", (int) xTraverse, (int) yTraverse);
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break; // Prevent Map[a][b] from being called out of range
            }
            // printf("X+ | XT: %f, YT: %f\n", xTraverse, yTraverse);
            if (Map[(int) xTraverse][(int) yTraverse] == 1) // If the square in the map is '1'
            {
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                // printf("DistanceFromStart: %f, Configured: %f\n", DistanceFromStart, ConfiguredDistance);
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001) // Is this the lowest distance logged (compare to vert if hor and vice versa)
                {
                    // printf("Lowest Before: %f\n", LowestDistance);
                    LowestDistance = DistanceFromStart;
                    // printf("Logging Distance: %f\n", LowestDistance);
                    isHorizontal = true;
                    
                    // printf("L: %f\n", LowestDistance);
                }
                break;
            }
            xTraverse += 1;
            // printf("%f", xTraverse);
            if (RayY < 0)
            {
                yTraverse += (RayY / RayX);
            }
            else
            {
                yTraverse += (RayY / RayX);
            } // We travel RayY distance per 1 unit of X traversed
            // printf("%f", yTraverse);
        }
        
    }
    else if (RayX < 0)
    {
        DistToStart = PlayerX - (int) PlayerX;
        xTraverse = PlayerX - DistToStart;
        yTraverse = PlayerY - RayY * (DistToStart / RayX);
        ConfiguredDistance = sqrtf((yTraverse - PlayerY) * (yTraverse - PlayerY) + (xTraverse - PlayerX) * (xTraverse - PlayerX)); // This probably (definintely) can be optimized)
        
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break; // Prevent Map[a][b] from being called out of range
            }
            // printf("%f, fuck: %f\n\n", xTraverse, yTraverse);
            // printf("X- | XT: %f, YT: %f\n", xTraverse, yTraverse);
            if (Map[(int) (xTraverse - 1)][(int) yTraverse] == 1) // If the square in the map is '1'
            {
                // printf("pass\n");
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                // printf("DistanceFromStart: %f, Configured: %f\n", DistanceFromStart, ConfiguredDistance);
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001) // Is this the lowest distance logged (compare to vert if hor and vice versa)
                {
                   //  printf("Lowest Before: %f\n", LowestDistance);
                    LowestDistance = DistanceFromStart;
                    // printf("Logging Distance: %f\n", LowestDistance);
                    // printf("L: %f\n", LowestDistance);
                    isHorizontal = true;
                }
                break;
            }
            xTraverse -= 1;
            if (RayY < 0)
            {
                yTraverse -= (RayY / RayX);
            }
            else
            {
                yTraverse -= (RayY / RayX);
            } // this may suposed to be playaer position, not (ray y) + ...
        }
    }
    
    if (RayY > 0) // if the player is facing non-horiz try to check for an intersection vertically aginst a wall
    {
        DistToStart = (1 - (PlayerY - (int) PlayerY)); // Configure the distance to get to a horizontal grid line
        yTraverse = PlayerY + DistToStart;
        xTraverse = PlayerX + RayX * (DistToStart / RayY);
        ConfiguredDistance = sqrtf((yTraverse - PlayerY) * (yTraverse - PlayerY) + (xTraverse - PlayerX) * (xTraverse - PlayerX)); // This probably (definintely) can be optimized)
        
        // printf("we're in Ray Y > 0\n\n");
        
        for (int i = 0; i < MAXCHECK; i++)
        {
            // printf("Y+ | XT: %f, YT: %f\n", xTraverse, yTraverse);
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break; // Prevent Map[a][b] from being called out of range
            }
            if (Map[(int) xTraverse][(int) yTraverse] == 1) // If the square in the map is '1'
            {
                // printf("pass\n");
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                // printf("DistanceFromStart: %f, Configured: %f\n", DistanceFromStart, ConfiguredDistance);
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001) // Is this the lowest distance logged (compare to vert if hor and vice versa)
                {
                    // printf("Lowest Before: %f\n", LowestDistance);
                    LowestDistance = DistanceFromStart;
                    // printf("Logging Distance: %f\n", LowestDistance);
                    // printf("L: %f\n", LowestDistance);
                    isHorizontal = false;
                }
                break;
            }
            yTraverse += 1;
            if (RayX < 0)
            {
                xTraverse += (RayX / RayY);
            }
            else
            {
                xTraverse += (RayX / RayY);
            };
        }
    }
    else if (RayY < 0)
    {
        DistToStart = PlayerY - (int) PlayerY;
        yTraverse = PlayerY - DistToStart;
        xTraverse = PlayerX - (RayX * (DistToStart / RayY));
        
        for (int i = 0; i < MAXCHECK; i++)
        {
            if (xTraverse > (MapWidth - 1) || yTraverse > (MapHeight - 1) || xTraverse < 0 || yTraverse < 0)
            {
                break; // Prevent Map[a][b] from being called out of range
            }
            // printf("Y- | XT: %f, YT: %f\n", xTraverse, yTraverse);
            if (Map[(int) xTraverse][(int) (yTraverse - 1)] == 1) // If the square in the map is '1'
            {
                // printf("pass\n");
                DistanceFromStart = sqrtf((xTraverse - PlayerX) * (xTraverse - PlayerX) + (yTraverse - PlayerY) * (yTraverse - PlayerY));
                // printf("DistanceFromStart: %f, Configured: %f\n", DistanceFromStart, ConfiguredDistance);
                if (DistanceFromStart < LowestDistance || LowestDistance < 0.001) // Is this the lowest distance logged (compare to vert if hor and vice versa)
                {
                    // printf("Lowest Before: %f\n", LowestDistance);
                    LowestDistance = DistanceFromStart;
                    // printf("Logging Distance: %f\n", LowestDistance);
                    isHorizontal = false;
                    // printf("L: %f\n", LowestDistance);
                }
                break;
            }
            yTraverse -= 1;
            if (RayX < 0)
            {
                xTraverse -= (RayX / RayY);
            }
            else
            {
                xTraverse -= (RayX / RayY);
            }
        }
    }
    
    // printf("Lowest Distance: %f\n", LowestDistance);

    if (LowestDistance < 0.001)
    {
        return 1000;
    }
    else
    {
        return LowestDistance;
    }
}

void HandleMovement(SDL_Event *event)
{
    float const RotateAngle = 5;
    float RotateRadian;
    float TempX;
    float TempY;
    DirectionAbsoluteRadian = atan2(DirectionY, DirectionX);

    
    switch (event->key.keysym.sym)
    {
        case SDLK_w:
            PlayerX = (PlayerX + 0.1 * cosf(DirectionAbsoluteRadian));
            PlayerY = (PlayerY + 0.1 * sinf(DirectionAbsoluteRadian));
            printf("%f, %f\n", PlayerX, PlayerY);
            // printf("%f, %f\n", DirectionX, DirectionY);
            break;
        case SDLK_a:
            PlayerX = (PlayerX + 0.1 * cosf(DirectionAbsoluteRadian + M_PI / 2));
            PlayerY = (PlayerY + 0.1 * sinf(DirectionAbsoluteRadian + M_PI / 2));
            printf("%f, %f\n", PlayerX, PlayerY);
            break;
        case SDLK_s:
            PlayerX = (PlayerX + 0.1 * cosf(DirectionAbsoluteRadian + M_PI));
            PlayerY = (PlayerY + 0.1 * sinf(DirectionAbsoluteRadian + M_PI));
            printf("%f, %f\n", PlayerX, PlayerY);
            break;
        case SDLK_d:
            PlayerX = (PlayerX + 0.1 * cosf(DirectionAbsoluteRadian + 3 * M_PI / 2));
            PlayerY = (PlayerY + 0.1 * sinf(DirectionAbsoluteRadian + 3 * M_PI / 2));
            printf("%f, %f\n", PlayerX, PlayerY);
            break;
        case SDLK_LEFT:
            RotateRadian = RotateAngle * M_PI / 180;
            TempX = DirectionX * cosf(RotateRadian) - DirectionY * sinf(RotateRadian);
            TempY = DirectionX * sinf(RotateRadian) + DirectionY * cosf(RotateRadian);
            DirectionX = TempX;
            DirectionY = TempY;
            break;
        case SDLK_RIGHT:
            RotateRadian = RotateAngle * M_PI / 180;
            TempX = DirectionX * cosf(RotateRadian) + DirectionY * sinf(RotateRadian);
            TempY = -DirectionX * sinf(RotateRadian) + DirectionY * cosf(RotateRadian);
            DirectionX = TempX;
            DirectionY = TempY;
            break;
        default:
            break;
    }
}

void NormalizeDirectionVector(float DirectionX, float DirectionY)
{
    
}

 

 
 
